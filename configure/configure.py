#!/usr/bin/python
#
# Generate the build tree and Makefiles for PyQwt3D.
#
# Copyright (C) 2004-2005 Gerard Vermeulen
#
# This file is part of PyQwt3D.
#
# PyQwt3D is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# PyQwt3D is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along
# with PyQwt3D; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
#
# In addition, as a special exception, Gerard Vermeulen gives permission to
# link PyQwt3D dynamically with commercial, non-commercial or educational
# versions of Qt, PyQt and sip, and distribute PyQwt3D in this form, provided
# that equally powerful versions of Qt, PyQt and sip have been released under
# the terms of the GNU General Public License.
#
# If PyQwt3D is dynamically linked with commercial, non-commercial or
# educational versions of Qt, PyQt and sip, PyQwt3D becomes a free plug-in for
# a non-free program.


import compileall
import glob
import optparse
import os
import pprint
import re
import shutil
import sys

import sipconfig
import pyqtconfig


def lazy_copy_file(source, target):
    """Lazy copy a file to another file:
    - check for a SIP time stamp to skip,
    - check if source and target do really differ,
    - copy the source file to the target if they do,
    - return True on copy and False on no copy.
    """
    if not os.path.exists(target):
        shutil.copy2(source, target)
        return True

    sourcelines = open(source).readlines()
    targetlines = open(target).readlines()

    # global length check
    if len(sourcelines) != len(targetlines):
        shutil.copy2(source, target)
        return True
    
    # skip a SIP time stamp 
    if (len(sourcelines) > 3
        and sourcelines[3].startswith(' * Generated by SIP')
        ):
        line = 4
    else:
        line = 0
        
    # line by line check
    while line < len(sourcelines):
        if sourcelines[line] != targetlines[line]:
            shutil.copy2(source, target)
            return True
        line = line + 1
        
    return False

# lazy_copy_file()


def copy_files(sources, directory):
    """Copy a list of files to a directory
    """ 
    for source in sources:
        shutil.copy2(source, os.path.join(directory, os.path.basename(source)))

# copy_files()


def generate_init_py(target, configuration):
    """Generate an __init__.py file to alias helper classes away if needed.
    """
    version = configuration.sip_version
    version_str = configuration.sip_version_str

    init_py = open(target, 'w')
    init_py.write(os.linesep.join([
        'from _Qwt3D import *',
        '',
        ]))
    if (version & 0xffff00 < 0x040200):
        init_py.write(os.linesep.join([
            '# Alias the helper classes away.',
            'del PyFunction',
            'from _Qwt3D import PyFunction as Function',
            'del PyParametricSurface',
            'from _Qwt3D import PyParametricSurface as ParametricSurface',
            '',
            ]))

# generate_init_py()
    

def check_numarray(configuration, options):
    """See if the numarray extension has been installed.
    """
    if options.disable_numarray:
        options.excluded_features.append("-x HAS_NUMARRAY")
        return options
       
    try:
        import numarray
        # Try to find numarray/arrayobject.h.
        numarray_inc = os.path.join(
            configuration.py_inc_dir, "numarray", "arrayobject.h")
        if os.access(numarray_inc, os.F_OK):
            print "Found numarray-%s.\n" % numarray.__version__
            options.extra_defines.append("HAS_NUMARRAY")
        else:
            print ("numarray has been installed, "
                   "but its headers are not in the standard location.\n"
                   "PyQwt3D will be build without support for numarray.\n"
                   "(Linux users may have to install a development package)\n"
                   )
            raise ImportError
    except ImportError:
        options.excluded_features.append("-x HAS_NUMARRAY")
        print ("Failed to import numarray: "
               "PyQwt3D will be build without support for numarray.\n"
               )
        
    return options

# check_numarray()


def check_numeric(configuration, options):
    """See if the Numeric extension has been installed.
    """
    if options.disable_numeric:
        options.excluded_features.append("-x HAS_NUMERIC")
        return options
           
    try:
        import Numeric
        # Try to find Numeric/arrayobject.h.
        numeric_inc = os.path.join(
            configuration.py_inc_dir, "Numeric", "arrayobject.h")
        if os.access(numeric_inc, os.F_OK):
            print "Found Numeric-%s.\n" % Numeric.__version__
            options.extra_defines.append("HAS_NUMERIC")
        else:
            print ("Numeric has been installed, "
                   "but its headers are not in the standard location.\n"
                   "PyQwt3D will be build without support for Numeric.\n"
                   "(Linux users may have to install a development package)\n"
                   )
            raise ImportError
    except ImportError:
        options.excluded_features.append("-x HAS_NUMERIC")
        print ("Failed to find Numeric: "
               "PyQwt3D will be build without support for Numeric.\n"
               )
        
    return options

# check_numeric()


def check_sip(configuration, options):
    """Account for SIP differences with a timeline and an include directory.
    """
    version = configuration.sip_version
    version_str = configuration.sip_version_str
    required = 'PyQwt3D requires SIP-4.3.x, -4.2.x, -4.1.x, or -4.0.x.'
    
    print "Found SIP-%s.\n" % version_str

    # SIP-4.3.x and SIP-4.2.1 behave similar for PyQwt3D
    if 0x040200 < version & 0xffffff < 0x040400:
        options.timelines.append('-t SIP_4_2_1')
        # SIP assumes POSIX style path separators
        options.sip_include_dirs.append(
            "-I %s" % os.path.join(os.pardir, 'sip0402').replace('\\', '/')
            )
    elif version & 0xffffff == 0x040200:
        options.timelines.append('-t SIP_4_2_0')
        # SIP assumes POSIX style path separators
        options.sip_include_dirs.append(
            "-I %s" % os.path.join(os.pardir, 'sip0402').replace('\\', '/')
            )
    elif version & 0xffff00 == 0x040100:
        options.timelines.append('-t SIP_4_1_0')
        # SIP assumes POSIX style path separators
        options.sip_include_dirs.append(
            "-I %s" % os.path.join(os.pardir, 'sip0401').replace('\\', '/')
            )
    elif version & 0xffff00 == 0x040000: 
        options.timelines.append('-t SIP_4_0_0')
        # SIP assumes POSIX style path separators
        options.sip_include_dirs.append(
            "-I %s" % os.path.join(os.pardir, 'sip0400').replace('\\', '/')
            )
    else:
        raise SystemExit, required

    return options

# check_sip()


def check_compiler(configuration, options):
    """Adapt to different compilers by means of mutually excluding features
    """
    makefile = sipconfig.Makefile(configuration=configuration)
    generator = makefile.optional_string('MAKEFILE_GENERATOR', 'UNIX')
    # FIXME: 'MSVC' should be worse than 'MSVC.NET'
    if generator in ['MSVC', 'MSVC.NET']:
        options.excluded_features.append('-x NO_MSVC')
        options.extra_cxxflags.extend(['-GR', '-GX'])
    else:
        options.excluded_features.append('-x IS_MSVC')
    
    return options

# check_compiler()


def check_os(configuration, options):
    """Adapt to different operating systems
    """
    print "Found '%s' operating system:" % os.name
    print sys.version
    print

    if os.name == 'nt':
        options.extra_defines.append('WIN32')

    return options

# check_os()


def fix_build_file(name, extra_sources, extra_headers, extra_moc_headers):
    """Extend the targets of a SIP build file with extra files 
    """
    
    keys = ('target', 'sources', 'headers', 'moc_headers')
    sbf = {}
    for key in keys:
        sbf[key] = []

    # Parse,
    nr = 0
    for line in open(name, 'r'):
        nr += 1
        if line[0] != '#':
            eq = line.find('=')
            if eq == -1:
                raise SystemExit, (
                    '"%s\" line %d: Line must be in the form '
                    '"key = value value...."' % (name, nr)
                    )
        key = line[:eq].strip()
        value = line[eq+1:].strip()
        if key in keys:
            sbf[key].append(value)

    # extend,
    sbf['sources'].extend(extra_sources)
    sbf['headers'].extend(extra_headers)
    sbf['moc_headers'].extend(extra_moc_headers)

    # and write.
    output = open(name, 'w')
    for key in keys:
        if sbf[key]:
            print >> output, '%s = %s' % (key, ' '.join(sbf[key]))

# fix_build_file()


def parse_args():
    """Return the parsed options and args from the command line
    """

    usage = (
        'python configure.py [options]'
        '\n\nEach option takes at most one argument, but some options'
        '\naccumulate arguments when repeated. For example, invoke:'
        '\n\n\tpython configure.py -I %s -I %s'
        '\n\nto search the current *and* parent directories for headers.'
        ) % (os.curdir, os.pardir)

    parser = optparse.OptionParser(usage=usage)

    common_options = optparse.OptionGroup(parser, 'Common options')
    common_options.add_option(
        '-Q', '--qwtplot3d-sources', default='', action='store',
        type='string', metavar='/sources/of/qwtplot3d',
        help=('compile and link the QwtPlot3D source files in'
              ' /sources/of/qwtplot3d statically into PyQwt3D'
              ' (required on Windows)'))
    common_options.add_option(
        '-Z', '--zlib-sources', default='', action='store',
        type='string', metavar='/sources/of/zlib',
        help=('compile and link the QwtPlot3D source files in'
              ' /sources/of/zlib statically into PyQwt3D'
              ' (the -Z option is ignored without the -Q option)'))
    common_options.add_option(
        '-D', '--extra-defines', default=[], action='append',
        type='string', metavar='GL2PS_HAVE_ZLIB',
        help=('add an extra preprocessor definition'
              ' (to enable compressed EPS/PDF/PS output with the -Q option)'))
    common_options.add_option(
        '-I', '--extra-include-dirs', default=[], action='append',
        type='string', metavar='/usr/include/qwtplot3d',
        help=('add an extra directory to search for headers'
              ' (the compiler must be able to find the QwtPlot3D headers'
              ' without the -Q option)'))
    common_options.add_option(
        '-L', '--extra-lib-dirs', default=[], action='append',
        type='string', metavar='/usr/lib/qt3/lib',
        help=('add an extra directory to search for libraries'
              ' (the linker must be able to find the QwtPlot3D library'
              ' without the -Q option)'))
    common_options.add_option(
        '-j', '--jobs', default=0, action='store',
        type='int', metavar='N',
        help=('concatenate the SIP generated code into N files'
              ' [default 1 per class] (to speed up make by running '
              ' simultaneous jobs on multiprocessor systems)'))
    common_options.add_option(
        '-l', '--extra-libs', default=[], action='append',
        type='string', metavar='z',
        help=('add an extra library (to link the zlib library, you must'
              ' specify "zlib" or "zlib1" on Windows'
              ' and "z" on POSIX and MacOS/X)'))
    parser.add_option_group(common_options)

    make_options = optparse.OptionGroup(parser, 'Make options')
    make_options.add_option(
        '--debug', default=False, action='store_true',
        help='enable debugging symbols [default disabled]')
    make_options.add_option(
        '--extra-cflags', default=[], action='append',
        type='string', metavar='EXTRA_CFLAG',
        help='add an extra C compiler flag')
    make_options.add_option(
        '--extra-cxxflags', default=[], action='append',
        type='string', metavar='EXTRA_CXXFLAG',
        help='add an extra C++ compiler flag')
    make_options.add_option(
        '--extra-lflags', default=[], action='append',
        type='string', metavar='EXTRA_LFLAG',
        help='add an extra linker flag')
    parser.add_option_group(make_options)

    sip_options = optparse.OptionGroup(parser, 'SIP options')
    sip_options.add_option(
        '-x', '--excluded-features', default=[], action='append',
        type='string', metavar='EXTRA_SENSORY_PERCEPTION',
        help=('add a feature for SIP to exclude'
              ' (normally one of the features in sip/features.sip)'))
    sip_options.add_option(
        '-t', '--timelines', default=[], action='append',
        type='string', metavar='ESP_3_2_1',
        help=('add a timeline for SIP to adapt to a library version'
              ' (normally one of the timeline options in sip/timelines.sip)'))
    sip_options.add_option(
        '--sip-include-dirs', default=[os.path.join(os.pardir, 'sip')],
        action='append', type='string', metavar='SIP_INCLUDE_DIR',
        help='add an extra directory for SIP to search')
    sip_options.add_option(
        '--tracing', default=False, action='store_true',
        help=('enable tracing of the execution of the bindings'
              ' [default disabled]'))
    parser.add_option_group(sip_options)
    
    detection_options = optparse.OptionGroup(parser, 'Detection options')
    detection_options.add_option(
        '--disable-numarray', default=False, action='store_true',
        help='disable detection and use of numarray [default enabled]')
    detection_options.add_option(
        '--disable-numeric', default=False, action='store_true',
        help='disable detection and use of Numeric [default enabled]')
    parser.add_option_group(detection_options)

    options, args =  parser.parse_args()
    
    # tweak some of the options to facilitate later processing
    if options.jobs < 1:
        options.jobs = ''
    else:
        options.jobs = '-j %s' % options.jobs
        
    options.excluded_features = [
        ('-x %s' % f) for f in options.excluded_features
        ]

    # SIP assumes POSIX style path separators
    options.sip_include_dirs = [
        ('-I %s' % f).replace('\\', '/') for f in options.sip_include_dirs
    ]
    
    options.timelines = [
        ('-t %s' % t) for t in options.timelines
        ]

    if options.tracing:
        options.tracing = '-r'
    else:
        options.tracing = ''
        
    if options.qwtplot3d_sources == '':
        options.zlib_sources = ''

    return options, args

# parse_args()


def main():
    
    # parse the command line
    options, args = parse_args()

    print "Command line options:"
    pprint.pprint(options.__dict__)
    print

    # initialize
    configuration = pyqtconfig.Configuration()
    build_dir = "Qwt3D"
    tmp_dir = "tmp-" + build_dir
    build_file = os.path.join(tmp_dir, "qwt3d.sbf")
    mod_dir = os.path.join(configuration.default_mod_dir, 'Qwt3D')
    sip_dir = os.path.join(configuration.pyqt_sip_dir, 'Qwt3D')
    extra_sources = []
    extra_headers = []
    extra_moc_headers = []

    # extend the options
    options = check_sip(configuration, options)
    options = check_os(configuration, options)
    options = check_compiler(configuration, options)
    options = check_numarray(configuration, options)
    options = check_numeric(configuration, options)

    # do we compile and link the sources of QwtPlot3D into PyQwt3D?
    if options.qwtplot3d_sources:
        # yes, zap all 'qwtplot3d'
        while options.extra_libs.count('qwtplot3d'):
            options.extra_libs.remove('qwtplot3d')
    elif 'qwtplot3d' not in options.extra_libs:
        # no, add 'qwtplot3d' if needed
        options.extra_libs.append('qwtplot3d')

    # do we also compile and link the sources of zlib into PyQwt3D?
    if options.zlib_sources:
        options.extra_defines.append('GL2PS_HAVE_ZLIB')

    print "Extended options:"
    pprint.pprint(options.__dict__)
    print
    
    # do we compile and link the sources of QwtPlot3D statically into PyQwt3D?
    if options.qwtplot3d_sources:
        extra_sources += glob.glob(os.path.join(
            options.qwtplot3d_sources, 'src', '*.cpp'))
        extra_sources += glob.glob(os.path.join(
            options.qwtplot3d_sources, '3rdparty', 'gl2ps', '*.c'))
        extra_headers += glob.glob(os.path.join(
            options.qwtplot3d_sources, 'include', '*.h'))
        extra_headers += glob.glob(os.path.join(
            options.qwtplot3d_sources, '3rdparty', 'gl2ps', '*.h'))
        extra_moc_headers = []
        for header in extra_headers:
            text = open(header).read()
            if re.compile(r'^\s*Q_OBJECT', re.M).search(text):
                extra_moc_headers.append(header)

    # do we compile and link the sources of zlib statically into PyQwt3D?
    if options.zlib_sources:
        examples = ('example.c', 'minigzip.c')
        for source in glob.glob(os.path.join(options.zlib_sources, '*.c')):
            if os.path.basename(source) not in examples:
                extra_sources.append(source)
        extra_headers += glob.glob(os.path.join(
            options.zlib_sources, '*.h'))

    # add the interface to the numerical Python extensions
    extra_sources += glob.glob(os.path.join(os.pardir, 'numpy', '*.cpp'))
    extra_headers += glob.glob(os.path.join(os.pardir, 'numpy', '*.h'))

    # put all code into a clean temporary directory
    try:
        shutil.rmtree(tmp_dir)
    except:
        pass
    try:
        os.mkdir(tmp_dir)
    except:
        raise SystemExit, "Failed to create the temporary build directory"

    # copy the extra files
    copy_files(extra_sources, tmp_dir)
    copy_files(extra_headers, tmp_dir)
    copy_files(extra_moc_headers, tmp_dir)

    # fix '#include "gl2ps".h' because gl2ps.h got relocated 
    if options.qwtplot3d_sources:
        for source in [os.path.join(tmp_dir, 'qwt3d_io_gl2ps.cpp')]:
            text = open(source).read()
            if -1 != text.find('../3rdparty/gl2ps/'): 
                open(source, 'w').write(text.replace('../3rdparty/gl2ps/', ''))

    # invoke SIP
    cmd = " ".join(
        [configuration.sip_bin,
         # SIP assumes POSIX style path separators
         #"-I", os.path.join(os.pardir, "sip").replace("\\", "/"),
         "-I", configuration.pyqt_sip_dir.replace("\\", "/"),
         "-b", build_file,
         "-c", tmp_dir,
         options.jobs,
         options.tracing,
         configuration.pyqt_qt_sip_flags,
         ]
        + options.sip_include_dirs
        + options.excluded_features
        + options.timelines
        # SIP assumes POSIX style path separators
        + [os.path.join(os.pardir, "sip", "qwt3dmod.sip").replace("\\", "/")]
        )

    print "sip invokation:"
    pprint.pprint(cmd)
    print

    if os.path.exists(build_file):
        os.remove(build_file)
    os.system(cmd)
    if not os.path.exists(build_file):
        raise SystemExit, 'SIP failed to generate the C++ code.'

    # fix the SIP build file
    fix_build_file(build_file,
                   [os.path.basename(f) for f in extra_sources],
                   [os.path.basename(f) for f in extra_headers],
                   [os.path.basename(f) for f in extra_moc_headers])
    
    # Windows fix: resolve the scope of POINTS in enumValues[]
    for source in glob.glob(os.path.join(tmp_dir, '*.cpp')):
        text = open(source).read()
        # sipNm__Qwt3D_POINTS changed between: SIP-4.2 and SIP-4.2.1
        if (-1 != text.find('{sipNm__Qwt3D_POINTS, POINTS')):
                text = text.replace('{sipNm__Qwt3D_POINTS, POINTS',
                                    '{sipNm__Qwt3D_POINTS, Qwt3D::POINTS')
                open(source, 'w').write(text)

    # generate __init__.py'
    generate_init_py(os.path.join(tmp_dir, '__init__.py'), configuration)

    # copy lazily to the build directory to speed up recompilation
    if not os.path.exists(build_dir):
        try:
            os.mkdir(build_dir)
        except:
            raise SystemExit, "Failed to create the build directory"

    lazy_copies = 0
    for pattern in ('*.c', '*.cpp', '*.h', '*.py', '*.sbf'):
        for source in glob.glob(os.path.join(tmp_dir, pattern)):
            target = os.path.join(build_dir, os.path.basename(source))
            if lazy_copy_file(source, target):
                print "Copy %s -> %s." % (source, target)
                lazy_copies += 1
    print "%s file(s) lazily copied." % lazy_copies

    # byte-compile the Python files
    compileall.compile_dir(build_dir, 1, mod_dir)

    # files to be installed
    installs = []
    installs.append([[os.path.basename(f) for f in glob.glob(
        os.path.join(build_dir, '*.py*'))], mod_dir])
    for option in options.sip_include_dirs:
        # split and undo the POSIX style path separator
        directory = option.split()[-1].replace('/', os.sep)
        if directory.startswith(os.pardir):
            installs.append([[os.path.join(os.pardir, f) for f in glob.glob(
                os.path.join(directory, "*.sip"))], sip_dir])

    # module makefile
    makefile = sipconfig.ModuleMakefile(
        configuration = configuration,
        build_file = os.path.basename(build_file),
        dir = build_dir,
        install_dir = mod_dir,
        installs = installs,
        qt = 1,
        opengl = 1,
        warnings = 1,
        debug = options.debug,
        )
    makefile.extra_cflags.extend(options.extra_cflags)
    makefile.extra_cxxflags.extend(options.extra_cxxflags)
    makefile.extra_defines.extend(options.extra_defines)
    makefile.extra_include_dirs.extend(options.extra_include_dirs)
    makefile.extra_lflags.extend(options.extra_lflags)
    makefile.extra_libs.extend(options.extra_libs)
    makefile.extra_lib_dirs.extend(options.extra_lib_dirs)
    if configuration.sip_version < 0x040000:
        makefile.extra_libs.insert(0, makefile.module_as_lib('qt'))
        makefile.extra_libs.insert(0, makefile.module_as_lib('qtgl'))
    makefile.generate()

    # main makefile
    sipconfig.ParentMakefile(
        configuration = configuration,
        subdirs = [build_dir],
    ).generate()

# main()


if __name__ == "__main__":
    main()

# Local Variables: ***
# mode: python ***
# End: ***
