\documentclass{manual}

% Links
\newcommand{\QwtPlotDdd}{\ulink{QwtPlot3D}
  {http://qwtplot3d.sourceforge.net}}
\newcommand{\QwtPlotDddApi}{\ulink{QwtPlot3D API documentation}
  {http://qwtplot3d.sourceforge.net/web/navigation/api_frame.html}}
\newcommand{\QwtPlotDddManual}{\ulink{QwtPlot3D manual}
  {http://qwtplot3d.sourceforge.net/web/navigation/manual_frame.html}}
\newcommand{\ZLib}{\ulink{ZLib}
  {http://www.gzip.org/zlib}}
\newcommand{\mailinglist}{\ulink{mailing list}
  {mailto:pyqwt-users@lists.sourceforge.net}}

% Source code
\newcommand{\snapshot}{\ulink{snapshot}
  {http://www.river-bank.demon.co.uk/download/snapshots}}
\newcommand{\Numeric}{\ulink{Numeric}
  {http://www.numpy.org}}
\newcommand{\NumericTarGz}{\ulink{Numeric-23.7.tar.gz}
  {http://prdownloads.sourceforge.net/numpy/Numeric-23.7.tar.gz?download}}
\newcommand{\numarray}{\ulink{numarray}
  {http://www.stsci.edu/resources/software_hardware/numarray}}
\newcommand{\numarrayTarGz}{\ulink{numarray-1.2.2.tar.gz}
  {http://prdownloads.sourceforge.net/numpy/numarray-1.2.2.tar.gz?download}}
\newcommand{\optik}{\ulink{optik}
  {http://optik.sourceforge.net}}
\newcommand{\NewSip}{\ulink{sip-4.2.tar.gz}
  {http://pyqwt.sourceforge.net/support/sip-4.2.tar.gz}}
\newcommand{\PyQtGpl}{\ulink{PyQt-x11-gpl-3.14.tar.gz}
  {http://pyqwt.sourceforge.net/support/PyQt-x11-gpl-3.14.tar.gz}}
\newcommand{\PyQtMac}{\ulink{PyQt-mac-gpl-3.14.tar.gz}
  {http://pyqwt.sourceforge.net/support/PyQt-mac-gpl-3.14.tar.gz}}
\newcommand{\PyQtCom}{\ulink{PyQt-commercial}
  {http://www.riverbankcomputing.co.uk/pyqt/buy.php}}
\newcommand{\PyQwtDddTarGz}{\ulink{PyQwt3D-0.1.tar.gz}
  {http://prdownloads.sourceforge.net/pyqwt/PyQwt3D-0.1.tar.gz?download}}
\newcommand{\QwtPlotDddTgz}{\ulink{qwtplot3d-0.2.4-beta.tgz}
  {http://prdownloads.sourceforge.net/qwtplot3d/qwtplot3d-0.2.4-beta.tgz?download}}
\newcommand{\QwtPlotDddZip}{\ulink{qwtplot3d-0.2.4-beta.zip}
  {http://prdownloads.sourceforge.net/qwtplot3d/qwtplot3d-0.2.4-beta.zip?download}}

% Installers for MS-Windows
\newcommand{\PythonMsi}{\ulink{python-2.4.msi}
  {http://python.org/ftp/python/2.4/python-2.4.msi}}
\newcommand{\NumericNewExe}{\ulink{Numeric-23.7.win32-py2.4.exe}
  {http://prdownloads.sourceforge.net/numpy/Numeric-23.7.win32-py2.4.exe?download}}
\newcommand{\numarrayNewExe}{\ulink{numarray-1.2.2.win32-py2.4.exe}
  {http://prdownloads.sourceforge.net/numpy/numarray-1.2.2.win32-py2.4.exe?download}}
\newcommand{\PythonExe}{\ulink{Python-2.3.5.exe}
  {http://www.python.org/ftp/python/2.3.5/Python-2.3.5.exe}}
\newcommand{\NumericExe}{\ulink{Numeric-23.7.win32-py2.3.exe}
  {http://prdownloads.sourceforge.net/numpy/Numeric-23.7.win32-py2.3.exe?download}}
\newcommand{\numarrayExe}{\ulink{numarray-1.2.2.win32-py2.3.exe}
  {http://prdownloads.sourceforge.net/numpy/numarray-1.2.2.win32-py2.3.exe?download}}
\newcommand{\QtNcExe}{\ulink{QtWin230-NonCommercial.exe}
  {ftp://ftp.trolltech.com/qt/non-commercial/QtWin230-NonCommercial.exe}}
\newcommand{\PyQtExe}{\ulink{PyQt-win-nc-msvc-3.13.exe}
  {http://pyqwt.sourceforge.net/support/PyQt-win-nc-msvc-3.13.exe}}
\newcommand{\PyQtEdu}{\ulink{PyQt-win-edu-msvc-3.13.exe}
  {http://pyqwt.sourceforge.net/support/PyQt-win-edu-msvc-3.13.exe}}
\newcommand{\PyQwtExe}{\ulink{PyQwt\_Qt230-4.1.win32-py2.3.exe}
  {http://prdownloads.sourceforge.net/pyqwt/PyQwt\_Qt230-4.1.win32-py2.3.exe?download}}

\newcommand{\PrerequisitesEnd}{
  To exploit the full power of the PyQwt3D, you should install at
  least one the Numerical Python extensions:
  \Numeric{} or its successor \numarray{}.
  I am using \NumericTarGz{} and \numarrayTarGz{}.
  PyQwt3D works with Numeric-21.3 and later.
  Get the latest version of Numarray, since it is newer and therefore less
  stable than Numeric.

  \begin{notice}[note]
    The PyQwt3D extension module containing statically linked sources of
    QwtPlot3D-0.2.4 coexists very well with system wide shared libraries
    of any version of QwtPlot3D.
  \end{notice}

  \begin{notice}[warning]
    PyQwt3D may not work with numarray on Linux systems, possibly due to a bug
    in the floating point excepion handling of glibc. 
    More information is to be found
    \ulink{here}{http://sourceforge.net/mailarchive/message.php?msg_id=9914816}
    and in related posts.
    PyQwt3D does not work with numarray and Matrox graphic cards on
    Mandrake-10.0 and SuSE-9.0.
    Your mileage may vary: PyQwt3D works with numarray with an ATI graphic card
    on SuSE-9.1.
  \end{notice}
}

\newcommand{\Future}{
  \begin{notice}[warning]
    The documentation is for the future PyQwt3D-0.1 which is only available
    from CVS.
  \end{notice}
}

\renewcommand{\Future}{}

\title{PyQwt3D Manual}

% boilerplate.tex?
\author{Gerard Vermeulen}

\date{\today}
\release{0.1}
\setshortversion{0.1}

\makeindex

\begin{document}

\maketitle

% This makes the contents more accessible from the front page of the HTML.
\ifhtml
\chapter*{Front Matter \label{front}}
\fi

\input{copyright}


\begin{abstract}

\noindent
PyQwt3D is a set of Python bindings for the \QwtPlotDdd{} library which extends
the Qt framework with widgets to visualize 3-dimensional data.
It allows you to integrate PyQt, Qt, QwtPlot3D, the Numerical Python
extensions, and optionally SciPy in a GUI Python application or in an
interactive Python session.

\end{abstract}

\tableofcontents

\chapter{Introduction\label{introduction}}

\Future{}

PyQwt3D is a set of Python bindings for the \QwtPlotDdd{} library which extends
the Qt framework with widgets to visualize 3-dimensional data.


\chapter{Installation\label{installation}}

\Future{}

\section{Installation prerequisites\label{prerequisites}}

\Future{}

\begin{notice}[note]
  Go immediately to \ref{win-nc-install}, if you want to install PyQwt3D for
  \QtNcExe{}. 
\end{notice}

Installation prerequisites for \PyQwtDddTarGz{} are:
\begin{enumerate}
\item
  \ulink{Python}{http://www.python.org}.\\
  Supported versions: Python-2.4.x and Python-2.3.x.
\item
  \ulink{Qt}{http://www.trolltech.com}.\\
  Supported versions: Qt-3.3.x, Qt-3.2.x, Qt-3.1.x, Qt-3.0.x,
  and also Qt-2.3.x if you use PyQwt3D's patched version of QwtPlot3D.
\item
  \NewSip{}.\\
  Supported versions: SIP-4.2.1 -4.2, -4.1.1, -4.1, -4.0.1, and -4.0,
  but SIP-4.2.x is recommended.\\
  Only SIP-4.2.x is capable to wrap all of the advanced C++ idioms of
  QwtPlot3D without hacks.\\
  If you use SIP-4.1.x, PyQwt3D is somewhat crippled,
  and if you use SIP-4.0.x, PyQwt3D is somewhat more crippled.
\item
  \PyQtGpl{}, \PyQtMac{} or \PyQtCom{}.\\
  Supported versions: PyQt-3.14, -3.13, -3.12, -3.11, and -3.10,
  but the most recent version gets most testing.
\item
  \QwtPlotDdd{}.\\
  Supported versions: \PyQwtDddTarGz{} or \QwtPlotDddZip{}.
  \PyQwtDddTarGz{} contains its own slightly patched version of \QwtPlotDdd{}.
  You can (but unless you are using Windows do not have to) compile and link
  the \QwtPlotDdd{} sources statically into the PyQwt3D extension module.
\item
  \ZLib{} is needed to enable compression in the PDF and PostScript output of
  \QwtPlotDdd{}.\\
  Supported versions: zlib-1.2.x, and zlib-1.1.x.
  \PyQwtDddTarGz{} contains the necessary source files of zlib-1.2.1 to remove
  the dependency on zlib (but you are free to use an already installed shared
  or dynamic load library of zlib). 
\end{enumerate}

\PrerequisitesEnd{}
  

\section{Installation\label{install}}

\Future{}

\subsection{Installation on \POSIX{} and MacOS/X\label{posix-install}}

\Future{}

The installation procedure consists of three steps:
\begin{enumerate}
\item
  Unpack \PyQwtDddTarGz{} and \QwtPlotDddTgz{}.
\item
  Do a quick start to test the installation by running the commands:
\begin{verbatim}
cd PyQwt3D-0.1
cd configure
python configure.py -Q /sources/of/qwtplot3d
make
make install
\end{verbatim}
  where the directory
  \file{/sources/of/qwtplot3d} must contain the directories \file{3rdparty},
  \file{include} and \file{src}.\\
  The installation will fail if Qt has been configured without runtime type
  information (RTTI).  In this case, run the commands:
\begin{verbatim}
cd PyQwt3D-0.1
cd configure
python configure.py -Q /sources/of/qwtplot3 --extra-cxxflags=-frtti
make
make install
\end{verbatim}
  where \code{-frtti} enables RTTI for g++.  Check your compiler documention
  for other C++ compilers.
\item
  Fine tune (optional)
  \begin{itemize}
    \item
      to enable compression of PostScript and PDF files by running the
      commands:
\begin{verbatim}
python configure.py -Q /sources/of/qwtplot3d -l z -D GL2PS_HAVE_ZLIB
make
make install
\end{verbatim}
      Add
\begin{verbatim}
-L /directory/with/libz.*
\end{verbatim}
      to the \file{configure.py} options, if the linker fails to find the zlib
      library.
    \item
      to use a the QwtPlot3D library on your system by running the commands:
\begin{verbatim}
rm -rf Qwt3D
python configure.py -I /usr/include/qwtplot3d
make
make install
\end{verbatim}
      where \file{/usr/include/qwtplot3d} is an example for the installation
      directory of the QwtPlot3D header files.
      Add
\begin{verbatim}
-L /directory/with/libqwtplot3d.*
\end{verbatim}
      to the \file{configure.py} options, if the linker fails to find the
      QwtPlot3D library.
  \end{itemize}
\end{enumerate}

\begin{notice}[note]
  \file{PyQwt-0.1/Makefile} is makefile for GNU make which contains more
  examples of how to invoke \file{configure.py}.
  Adapt and use it, if you have GNU make.
\end{notice}

\begin{notice}[note]
  If you run into problems, send a log to the \mailinglist{}.

  There are at least two options to log the output of make:
  \begin{enumerate}
  \item Invoke make, tie stderr to stdout, and redirect stdout to LOG.txt:
\begin{verbatim}
make all-static 2&>1 >LOG.txt
\end{verbatim}
    However, you do not see what is going on.
  \item Use script to capture all screen output of make to LOG.txt:
\begin{verbatim}
script -c 'make all-static' LOG.txt
\end{verbatim}
    The script command appeared in 3.0BSD and is part of util-linux.
  \end{enumerate}
\end{notice}

\begin{notice}[note]
  The configure.py script takes many options. The command
\begin{verbatim}
python configure.py -h
\end{verbatim}
  displays a full list of the available options:
  \verbatiminput{configure.help}
\end{notice}


\subsection{Installation on Windows with MSVC\label{win-install}}

\Future{}

\begin{notice}[note]
  I rely on your feedback to support PyQwt3D on Windows, since I have no
  commercial license for Qt and PyQt.
\end{notice}

The installation procedure consists of three steps:
\begin{enumerate}
\item
  Unpack \PyQwtDddTarGz{} or \QwtPlotDddZip{}.
\item
  Do a quick start to test the installation by running the commands:
\begin{verbatim}
cd PyQwt3D-0.1
cd configure
python configure.py -Q C:\sources\of\qwtplot3d
nmake
nmake install
\end{verbatim}
  where the folder
  \file{C:\textbackslash{}sources\textbackslash{}of\textbackslash{}qwtplot3d}
  must contain the folders \file{3rdparty}, \file{include} and \file{src}.
  You can also edit the file \file{go.bat} to suit your setup.
\item
  Fine tune (optional) by running the commands:
\begin{verbatim}
python configure.py -Q C:\sources\of\qwtplot3d -l zlib -D GL2PS_HAVE_ZLIB
nmake
nmake install
\end{verbatim}
    to enable compression of PostScript and PDF files. Add
\begin{verbatim}
-L C:\folder\containing\zlib.lib
\end{verbatim}
    to the \file{configure.py} options, if the linker fails to find the zlib
    library.
\end{enumerate}

\begin{notice}[note]
  The files \file{configure\textbackslash{}go.bat} for Qt-3.x and
  \file{configure\textbackslash{}nc-go.bat} for \QtNcExe{} are examples of
  how to automatize the invokations of \strong{configure.py}, \strong{nmake},
  and \strong{nmake install}.  Adapt and use one of those files.
\end{notice}

\begin{notice}[note]
  If you run into problems, send a log to the \mailinglist{}.

  Try
\begin{verbatim}
go.bat >LOG.txt
\end{verbatim}
  to make a log.
\end{notice}

\begin{notice}[note]
  The configure.py script takes many options. The command
\begin{verbatim}
python configure.py -h
\end{verbatim}
  displays a full list of the available options:
  \verbatiminput{configure.help}
\end{notice}

\begin{notice}[note]
  Since PyQwt3D wraps some classes and functions that are not exported from
  a QwtPlot3D dynamic load library, you have to compile and link the QwtPlot3D
  sources into PyQwt3D's extension module.
\end{notice}


\subsection{Installation for \QtNcExe{}\label{win-nc-install}}

\Future{}

First, you have to install Python, Numeric, Qt-Non-Commercial and
PyQt-Non-Commercial by executing the following installation programs:
\begin{enumerate}
  \item
    \QtNcExe{}
  \item
    \PythonExe{}
  \item
    \PyQtExe{} and make sure that you install the development tools.
  \item
    \NumericExe{}
\end{enumerate}

The installation procedure consists of two steps:
\begin{enumerate}
\item
  Unpack \PyQwtDddTarGz{} or \QwtPlotDddZip{}.
\item
  Do a quick start to test the installation by running the commands:
\begin{verbatim}
cd PyQwt3D-0.1
cd configure
nc-go.bat
\end{verbatim}
\end{enumerate}

\begin{notice}[note]
  If you run into problems, send a log to the \mailinglist{}.

  Try
\begin{verbatim}
nc-go.bat >LOG.txt
\end{verbatim}
  to make a log.
\end{notice}


\chapter{PyQwt3D Module Reference \label{reference}}

\Future{}

The reference should be used in conjunction with the \QwtPlotDddManual{}
and the \QwtPlotDddApi{}.
Only the differences specific to the Python bindings are documented here.

In this chapter, \emph{is not yet implemented} implies that the feature can
be easily implemented if needed, \emph{is not implemented} implies that the
feature is not easily implemented, and \emph{is not Pythonic} implies that
the feature will not be implemented because it violates the Python philosophy
(e.g. may use dangling pointers).

If a class is described as being \emph{fully implemented} then all non-private
member functions and all public class variables have been implemented.

Undocumented classes have not yet been implemented or are still experimental.

The classes in the QwtPlot3D library have quite a few protected attributes.
They are not yet available in Python (as far as I know, sip wraps protected
member function, but not protected attributes).
I may try to implement protected attributes on demand.


\section{Class reference \label{classes}}

\Future{}

\begin{classdesc}{Arrow}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{AutoScaler}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{Axis}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{AxisVector}{*args}
wraps \ctype{std::vector<Axis>}. See \ref{wrappers} for details.
\end{classdesc}

\begin{classdesc}{Cell}{*args}
wraps \ctype{std::vector<unsigned>}. See \ref{wrappers} for details.
\end{classdesc}

\begin{classdesc}{CellData}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{CellField}{*args}
wraps \ctype{std::vector<Cell>}. See \ref{wrappers} for details.
\end{classdesc}

\begin{classdesc}{Color}{*args}
\emph{is fully implemented}.\\
The abstract operator()() does not work with SIP-4.0.x and SIP-4.1.x.
\end{classdesc}

\begin{classdesc}{ColorLegend}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{Cone}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{CoordinateSystem}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{CrossHair}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{Data}{*args}
\emph{is fully implemented}.\\
FIXME: what to do with the protected data members?
\end{classdesc}

\begin{classdesc}{Dot}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{DoubleVector}{*args}
wraps \ctype{std::vector<double>}. See \ref{wrappers} for details.
\end{classdesc}

\begin{classdesc}{Drawable}{*args}
\emph{is fully implemented}.\\
FIXME: what to do with the protected data members?
\end{classdesc}

\begin{classdesc}{Enrichment}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{Freevector}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{FreeVectorField}{*args}
wraps \ctype{std::vector<FreeVector>}. See \ref{wrappers} for details.
\end{classdesc}

\begin{classdesc}{Function}{*args}
\emph{is fully implemented}.\\
The abstract operator()() works also with SIP-4.0.x and SIP-4.1.x thanks to
a hack.
\end{classdesc}

\begin{classdesc}{GLStateBewarer}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{GridData}{*args}
  \begin{itemize}
  \item{vertices}. The public data member:
\begin{verbatim}
DataMatrix vertices;
\end{verbatim}
    is not accessible. FIXME: how to wrap \class{DataMatrix} safely?
  \item{normals}. The public data member:
\begin{verbatim}
DataMatrix normals;
\end{verbatim}
    is not accessible. FIXME: how to wrap \class{DataMatrix} safely?
  \end{itemize}
\end{classdesc}

\begin{classdesc}{GridMapping}{*args}
\emph{is fully implemented}.\\
FIXME: what to do with the protected data members?
\end{classdesc}

\begin{classdesc}{IO}{*args}
  \begin{itemize}
  \item{defineInputHandler}. C++ declaration:
\begin{verbatim}
static bool defineInputHandler(QString const& format, Function func);
\end{verbatim}
    is not implemented (it is impossible to implement callbacks without an
    extra void pointer to hold a Python callable).
  \item{defineOutputHandler}. C++ declaration:
\begin{verbatim}
static bool defineOutputHandler(QString const& format, Function func);
\end{verbatim}
    is not implemented (it is impossible to implement callbacks without an
    extra void pointer to hold a Python callable).
  \end{itemize}
  SIP-4.1.x does not allow to wrap the operator
  \cfunction{bool IO::Function::operator()(Plot3D *, const QString \&) = 0}.\\
  SIP-4.0.x does not allow to wrap the class \code{IO::Functor} and all member
  functions using \code{IO::Functor}.
\end{classdesc}

\begin{classdesc}{Label}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{LinearAutoscaler}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{LinearScale}{*args}
\emph{is fully implemented}.\\
FIXME: what to do with the protected data members?
\end{classdesc}

\begin{classdesc}{LogScale}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{Mapping}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{NativeReader}{*args}
SIP-4.0.x does not allow to implement the fact that \class{NativeReader} is a
subclass of \class{IO.Function}.
\end{classdesc}

\begin{classdesc}{ParallelEpiped}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{ParametricSurface}{*args}
\emph{is fully implemented}.\\
The abstract operator()() works also with SIP-4.0.x and SIP-4.1.x thanks to
a hack.
\end{classdesc}

\begin{classdesc}{PixmapWriter}{*args}
\emph{is fully implemented}.\\
SIP-4.0.x does not allow to implement the fact that \class{PixmapWriter} is a
subclass of \class{IO.Function}.
\end{classdesc}

\begin{classdesc}{Plot3D}{*args}
\emph{is fully implemented}.\\
FIXME: what to do with the protected data members?\\
FIXME: the ConvertToSubClassCode is disabled on Windows, since it crashes.
\end{classdesc}

\begin{classdesc}{RGBA}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{Scale}{*args}
\emph{is fully implemented}.\\
FIXME: what to do with the protected data members?
\end{classdesc}

\begin{classdesc}{StandardColor}{*args}
\emph{is fully implemented}.\\
FIXME: does the operator()() work with SIP-4.0.x and SIP-4.1.x?\\
FIXME: what to do with the protected data members?
\end{classdesc}

\begin{classdesc}{SurfacePlot}{*args}
  \emph{is fully implemented}.
  \begin{itemize}
  \item{facets}. C++ declaration:
\begin{verbatim}
std::pair<int,int> facets() const;
\end{verbatim}
    returns a tuple of two Python ints.
  \item{loadFromData}. C++ declaration:
\begin{verbatim}
bool loadFromData(Qwt3D::Triple** data,
                  unsigned int columns, unsigned int rows,
                  bool uperiodic = false, bool vperiodic = false);
\end{verbatim}
    is wrapped by:
\begin{verbatim}
success = surfacePlot.loadFromData(data, uperiodic = False, vperiodic = False)
\end{verbatim}
    where \var{success} is \constant{True} or \constant{False}, \var{data}
    is convertable to a Numeric or numarray array of Python floats with a shape
    (N, M, 3), and \var{uperiodic} and \var{vperiodic} are Python bools.\\
    C++ declaration:
\begin{verbatim}
bool loadFromData(double** data, unsigned int columns, unsigned int rows,
                  double minx, double maxx, double miny, double maxy);
\end{verbatim}
    is wrapped by:
\begin{verbatim}
success = surfacePlot.loadFromData(data, minx, maxx, miny, maxy)
\end{verbatim}
    where \var{success} is \constant{True} or \constant{False}, \var{data}
    is convertable to a Numeric or numarray array of Python floats with a shape
    (N, M), and \var{minx}, \var{maxx}, \var{miny} and \var{maxy} are
    convertable to Python floats.\\
    C++ declaration:
\begin{verbatim}
bool loadFromData(Qwt3D::TripleField const& data,
                  Qwt3D::CellField const& poly);
\end{verbatim}
    is wrapped by:
\begin{verbatim}
success = surfacePlot.loadFromData(tripleField, cellField)
\end{verbatim}
    where \var{success} is \constant{True} or \constant{False},
    \var{tripleField} is a \class{TripleField}, and \var{cellField} is a
    \class{CellField}.
  \item{createDataRepresentation}. C++ declarations:
\begin{verbatim}
bool createDataRepresentation(
     Qwt3D::Triple** data, unsigned int columns, unsigned int rows,
     bool uperiodic = false, bool vperiodic = false);
bool createDataRepresentation(
     double** data, unsigned int columns, unsigned int rows,
     double minx, double maxx, double miny, double maxy);
bool createDataRepresentation(
     Qwt3D::TripleField const& data, Qwt3D::CellFieldconst& poly)
\end{verbatim}
    are deprecated and therefore not implemented.
  \item{readIn}. C++ declaration:
\begin{verbatim}
void readIn(Qwt3D::GridData& grid, Triple** data,
            unsigned int columns, unsigned int rows);
\end{verbatim}
    is wrapped by:
\begin{verbatim}
surfacePlot.readIn(gridData, data) 
\end{verbatim}
    where \var{gridData} is a \class{GridData}, and \var{data} is convertable
    to a Numeric or numarray array of Python floats with a shape (N, M, 3).\\
    C++ declaration:
\begin{verbatim}
void readIn(Qwt3D::GridData& grid, double** data,
            unsigned int columns, unsigned int rows,
            double minx, double maxx, double miny, double maxy);
\end{verbatim}
    is wrapped by:
\begin{verbatim}
surfacePlot.readIn(gridData, data, minx, maxx, miny, maxy)
\end{verbatim}
    where \var{gridData} is a \class{GridData}, \var{data} is convertable to
    a Numeric or numarray array of Python floats with a shape (N, M), and
    \var{minx}, \var{maxx}, \var{miny} and \var{maxy} are convertable to Python
    floats.
  \end{itemize}
\end{classdesc}

\begin{classdesc}{Triple}{*args}
  \begin{itemize}
  \item{operator *()}. C++ declaration:
\begin{verbatim}
Triple operator*(double, const Triple &);
\end{verbatim}
    is not implemented (not supported by SIP-4.2.x).
  \item{operator /()}. C++ declaration:
\begin{verbatim}
Triple operator/(double, const Triple &);
\end{verbatim}
    is not implemented (not supported by SIP-4.2.x).
  \end{itemize}
\end{classdesc}

\begin{classdesc}{TripleField}{*args}
wraps \ctype{std::vector<Triple>}. See \ref{wrappers} for details.
\end{classdesc}

\begin{classdesc}{Tuple}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{VectorWriter}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{VertexEnrichment}{*args}
\emph{is fully implemented}.
\end{classdesc}

\section{Wrappers for \ctype{std::vector<T>} \label{wrappers}}

\Future{}

PyQwt3D has a partial interface to the following C++ std::vector templates:
\begin{enumerate}
\item
  \class{AxisVector} for \ctype{std::vector<Axis>}
\item
  \class{Cell} for \ctype{std::vector<unsigned>}
\item
  \class{CellField} for \ctype{std::vector<Cell>}
\item
  \class{ColorVector} for \ctype{std::vector<RGBA>}
\item
  \class{DoubleVector} for \ctype{std::vector<double>}
\item
  \class{FreeVectorField} for \ctype{std::vector<FreeVectorField>}
\item
  \class{TripleField} for \ctype{std::vector<Triple>}
\end{enumerate}

The interface implements four constructors for each template instantianation --
taking Cell as example:
\begin{enumerate}
\item
  \code{Cell()}
\item
  \code{Cell(size)}
\item
  \code{Cell(size, item)}
\item
  \code{Cell(otherCell)}
\end{enumerate}

and 13 member functions -- taking Cell as example:
\begin{enumerate}
\item
  \code{result = cell.capacity()}
\item
  \code{cell.clear()}
\item
  \code{result = cell.empty()}
\item
  \code{result = cell.back()}
\item
  \code{result = cell.front()}
\item
  \code{result = cell.max_size()}
\item
  \code{cell.pop_back()}
\item
  \code{cell.push_back(item)}
\item
  \code{cell.reserve(size)}
\item
  \code{cell.reserve(size, item = 0)}
\item
  \code{cell.resize(size, item = 0)}
\item
  \code{result = cell.size()}
\item
  \code{cell.swap(otherCell)}
\end{enumerate}

Iterators are not yet implemented. However, the implementation of the
Python slots \function{__getitem__}, \function{__len__} and
\function{__setitem__} let you use those classes almost as a sequence.
For instance:

\verbatiminput{StdVectorExample.txt}

\section{Function reference \label{functions}}

\Future{}

FIXME

%begin{latexonly}
\renewcommand{\indexname}{Index}
%end{latexonly}
\input{\jobname.ind}

\end{document}

%% Local Variables:
%% fill-column: 79
%% End:

